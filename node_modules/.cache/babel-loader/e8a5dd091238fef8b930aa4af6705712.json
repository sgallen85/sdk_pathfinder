{"ast":null,"code":"import _regeneratorRuntime from\"/Users/sallen/Documents/GitHub/sdk_wayfinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/sallen/Documents/GitHub/sdk_wayfinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/Users/sallen/Documents/GitHub/sdk_wayfinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/sallen/Documents/GitHub/sdk_wayfinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{distance}from'./utils';/**\n * Path given by `findShortestPath` as list of sweep ids. It's a separate type\n * just in case the return type changes.\n */var Pathfinder=/*#__PURE__*/function(){// penalize sweeps vertically separated by this distance, in meters\n// penalize sweeps horizontally separated by this distance, in meters\nfunction Pathfinder(sweepData){var _this=this;_classCallCheck(this,Pathfinder);this.VERT_THRESHOLD=0.5;this.HORZ_THRESHOLD=10.0;this.graph={};this.path=[];this.sweepPositions={};// init sweepPositions\nsweepData.forEach(function(sweep){return _this.sweepPositions[sweep.sid]=sweep.position;});this.createGraph(sweepData);}/**\n   * Generate graph of sweep distances.\n   * @param {Sweep.SweepData[]} sweeps List of sweep data, such as `sdk.Model.getData().sweeps`\n   */_createClass(Pathfinder,[{key:\"createGraph\",value:function createGraph(sweeps){var graph={};for(var i=0;i<sweeps.length;i++){var sweep_a=sweeps[i];var adj={};var neighbor_sids=sweep_a.neighbors;for(var j=0;j<neighbor_sids.length;j++){var sweep_b_sid=neighbor_sids[j];var d=distance(sweep_a.position,this.sweepPositions[sweep_b_sid]);adj[sweep_b_sid]=d;}graph[sweep_a.sid]=adj;}this.graph=graph;}/**\n   * Heuristic function for A*. Just take Euclidean distance.\n   */},{key:\"heuristic\",value:function heuristic(i_sid,j_sid){var sweepPositions=this.sweepPositions;return distance(sweepPositions[i_sid],sweepPositions[j_sid]);}/**\n   * Additional penalty to avoid large vertical/horizontal jumps.\n   */},{key:\"penalty\",value:function penalty(i_sid,j_sid){var sweepPositions=this.sweepPositions;return Math.pow((sweepPositions[i_sid].y-sweepPositions[j_sid].y)/this.VERT_THRESHOLD,4)+(Math.pow(sweepPositions[i_sid].x-sweepPositions[j_sid].x,2)+Math.pow(sweepPositions[i_sid].z-sweepPositions[j_sid].z,2))/this.HORZ_THRESHOLD;}/**\n   * Find shortest path between two sweeps connected by valid movements.\n   * @param {string} a_sid SID of starting sweep.\n   * @param {string} b_sid SID of ending sweep.\n   * @returns {SweepPath} Path from `a_sid` to `b_sid`.\n   */},{key:\"findShortestPath\",value:function(){var _findShortestPath=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(a_sid,b_sid){var graph,ht,debug_n,min_sid,encountered_sids,i,_sid,neighbor_sids,_i,_sid2,dist,cost,sid,path;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:graph=this.graph;// check SIDs are valid\nif(!(graph[a_sid]===undefined||graph[b_sid]===undefined)){_context.next=4;break;}console.error('Sweep SID(s) is invalid.');return _context.abrupt(\"return\");case 4:ht={};// hash table that stores the following info for each encountered sweep:\nht[a_sid]={visited:false,distance:0,cost:0,parent:null};// loop A* algorithm\ndebug_n=0;// count number of iterations\ncase 7:if(!true){_context.next=22;break;}debug_n+=1;// find unvisited sweep with minimum cost = distance + heuristic\n// TODO: optimize with priority queue\nmin_sid=void 0;encountered_sids=Object.keys(ht);for(i=0;i<encountered_sids.length;i++){_sid=encountered_sids[i];if(!ht[_sid].visited&&(min_sid===undefined||ht[_sid].cost<ht[min_sid].cost)){min_sid=_sid;}}if(!(min_sid===undefined)){_context.next=15;break;}console.error('Could not find path; sweeps are not connected.');return _context.abrupt(\"return\");case 15:if(!(min_sid===b_sid)){_context.next=17;break;}return _context.abrupt(\"break\",22);case 17:// add all neighbors of `min_sid`\nht[min_sid].visited=true;neighbor_sids=Object.keys(graph[min_sid]);for(_i=0;_i<neighbor_sids.length;_i++){_sid2=neighbor_sids[_i];dist=ht[min_sid].distance+graph[min_sid][_sid2];cost=dist+this.penalty(min_sid,_sid2)+this.heuristic(_sid2,b_sid);if(_sid2 in ht){// if sweep has been encountered\nif(!ht[_sid2].visited&&ht[_sid2].cost>cost){// if not visited and smaller cost, then update\nht[_sid2].parent=min_sid;ht[_sid2].distance=dist;ht[_sid2].cost=cost;}}else{// if sweep has not been encountered yet\nht[_sid2]={visited:false,distance:dist,cost:cost,parent:min_sid};}}_context.next=7;break;case 22:console.log(\"Pathfind iterations: \".concat(debug_n));// traverse graph back to starting point\nsid=b_sid;path=[sid];while(ht[sid].parent!==null){sid=ht[sid].parent;path.push(sid);}path.reverse();return _context.abrupt(\"return\",path);case 28:case\"end\":return _context.stop();}}},_callee,this);}));function findShortestPath(_x,_x2){return _findShortestPath.apply(this,arguments);}return findShortestPath;}()}]);return Pathfinder;}();export{Pathfinder as default};","map":{"version":3,"sources":["/Users/sallen/Documents/GitHub/sdk_wayfinder/src/app/Pathfinder.ts"],"names":["distance","Pathfinder","sweepData","VERT_THRESHOLD","HORZ_THRESHOLD","graph","path","sweepPositions","forEach","sweep","sid","position","createGraph","sweeps","i","length","sweep_a","adj","neighbor_sids","neighbors","j","sweep_b_sid","d","i_sid","j_sid","y","x","z","a_sid","b_sid","undefined","console","error","ht","visited","cost","parent","debug_n","min_sid","encountered_sids","Object","keys","dist","penalty","heuristic","log","push","reverse"],"mappings":"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","sourcesContent":["import { Sweep, Vector3 } from '../mp/sdk';\nimport { distance } from './utils';\n\n/**\n * Path given by `findShortestPath` as list of sweep ids. It's a separate type\n * just in case the return type changes.\n */\nexport type SweepPath = string[];\n\n/**\n * Graph as adjacency list, with sweep ids mapping to a list of neighboring ids,\n * who each map to corresponding distances.\n */\ninterface SweepGraph {\n  [a_id: string]: AdjacencyNode;\n}\ninterface AdjacencyNode {\n  [b_id: string]: number;\n}\n\nexport interface SweepPositions {\n  [id: string]: Vector3;\n}\n\nexport default class Pathfinder {\n\n  private VERT_THRESHOLD = 0.5; // penalize sweeps vertically separated by this distance, in meters\n  private HORZ_THRESHOLD = 10.0; // penalize sweeps horizontally separated by this distance, in meters\n\n  private graph: SweepGraph = {};\n  public path: SweepPath = [];\n\n  private sweepPositions: SweepPositions = {};\n\n  constructor(sweepData: Sweep.SweepData[]) {\n    // init sweepPositions\n    sweepData.forEach(sweep => this.sweepPositions[sweep.sid] = sweep.position);\n    this.createGraph(sweepData);\n  }\n\n  /**\n   * Generate graph of sweep distances.\n   * @param {Sweep.SweepData[]} sweeps List of sweep data, such as `sdk.Model.getData().sweeps`\n   */\n  private createGraph(sweeps: Sweep.SweepData[]): void {\n    const graph: SweepGraph = {};\n    for (let i = 0; i < sweeps.length; i++) {\n      const sweep_a = sweeps[i];\n      const adj: AdjacencyNode = {};\n      const neighbor_sids = sweep_a.neighbors;\n      for (let j = 0; j < neighbor_sids.length; j++) {\n        const sweep_b_sid = neighbor_sids[j];\n        const d = distance(sweep_a.position, this.sweepPositions[sweep_b_sid]);\n        adj[sweep_b_sid] = d;\n      }\n      graph[sweep_a.sid] = adj;\n    }\n    this.graph = graph;\n  }\n\n  /**\n   * Heuristic function for A*. Just take Euclidean distance.\n   */\n  private heuristic(i_sid: string, j_sid: string): number {\n    const { sweepPositions } = this;\n    return distance(sweepPositions[i_sid], sweepPositions[j_sid]);\n  }\n\n  /**\n   * Additional penalty to avoid large vertical/horizontal jumps.\n   */\n  private penalty(i_sid: string, j_sid: string): number {\n    const { sweepPositions } = this;\n    return ((sweepPositions[i_sid].y - sweepPositions[j_sid].y) / this.VERT_THRESHOLD) ** 4\n      + (((sweepPositions[i_sid].x - sweepPositions[j_sid].x) ** 2 + (sweepPositions[i_sid].z - sweepPositions[j_sid].z) ** 2) / this.HORZ_THRESHOLD);\n  }\n\n  /**\n   * Find shortest path between two sweeps connected by valid movements.\n   * @param {string} a_sid SID of starting sweep.\n   * @param {string} b_sid SID of ending sweep.\n   * @returns {SweepPath} Path from `a_sid` to `b_sid`.\n   */\n  public async findShortestPath(a_sid: string, b_sid: string): Promise<SweepPath | undefined> {\n\n    const { graph } = this;\n\n    // check SIDs are valid\n    if (graph[a_sid] === undefined || graph[b_sid] === undefined) {\n      console.error('Sweep SID(s) is invalid.');\n      return;\n    }\n\n    const ht: any = {}; // hash table that stores the following info for each encountered sweep:\n    ht[a_sid] = { visited: false, distance: 0, cost: 0, parent: null };\n\n    // loop A* algorithm\n    let debug_n = 0; // count number of iterations\n\n    while (true) {\n      debug_n += 1;\n      // find unvisited sweep with minimum cost = distance + heuristic\n      // TODO: optimize with priority queue\n      let min_sid;\n      const encountered_sids = Object.keys(ht);\n      for (let i = 0; i < encountered_sids.length; i++) {\n        const sid = encountered_sids[i];\n        if (!ht[sid].visited && (min_sid === undefined || ht[sid].cost < ht[min_sid].cost)) {\n          min_sid = sid;\n        }\n      }\n      if (min_sid === undefined) {\n        console.error('Could not find path; sweeps are not connected.');\n        return;\n      }\n      // check if sweep is ending point\n      if (min_sid === b_sid) {\n        break;\n      }\n      // add all neighbors of `min_sid`\n      ht[min_sid].visited = true;\n      const neighbor_sids = Object.keys(graph[min_sid]);\n      for (let i = 0; i < neighbor_sids.length; i++) {\n        const sid = neighbor_sids[i];\n        const dist = ht[min_sid].distance + graph[min_sid][sid];\n        const cost = dist + this.penalty(min_sid, sid) + this.heuristic(sid, b_sid);\n        if (sid in ht) { // if sweep has been encountered\n          if (!ht[sid].visited && (ht[sid].cost > cost)) { // if not visited and smaller cost, then update\n            ht[sid].parent = min_sid;\n            ht[sid].distance = dist;\n            ht[sid].cost = cost;\n          }\n        } else { // if sweep has not been encountered yet\n          ht[sid] = { visited: false, distance: dist, cost: cost, parent: min_sid };\n        }\n      }\n    }\n    console.log(`Pathfind iterations: ${debug_n}`);\n\n    // traverse graph back to starting point\n    let sid = b_sid;\n    const path: string[] = [sid];\n    while (ht[sid].parent !== null) {\n      sid = ht[sid].parent as string;\n      path.push(sid);\n    }\n    path.reverse();\n    return path;\n\n  }\n}"]},"metadata":{},"sourceType":"module"}