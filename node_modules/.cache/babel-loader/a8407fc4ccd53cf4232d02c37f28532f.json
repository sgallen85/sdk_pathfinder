{"ast":null,"code":"import _regeneratorRuntime from\"/Users/sallen/Documents/GitHub/sdk_wayfinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/sallen/Documents/GitHub/sdk_wayfinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/Users/sallen/Documents/GitHub/sdk_wayfinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/sallen/Documents/GitHub/sdk_wayfinder/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{clamp}from'../utils';var CameraController=/*#__PURE__*/function(){function CameraController(){var _this=this;_classCallCheck(this,CameraController);this.u=0;this.length=0;this.up=void 0;this.inputs={curve:null,// THREE.Curve object\nspeed:1.5,// speed in meters per second\nverticalOffset:1.,// vertical offset from curve\nenabled:false,// true to move forward automatically, false to pause\nchangeUCallback:function changeUCallback(u){return null;}// callback eahc time u changes\n};this.outputs={camera:null};this.context=void 0;this.onInit=/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var curve,THREE,camera;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:curve=_this.inputs.curve;THREE=_this.context.three;camera=new THREE.PerspectiveCamera(45,1.333,1,1000);_this.outputs.camera=camera;_this.length=curve.getLength()-1;_this.up=new THREE.Vector3(0,1,0);case 6:case\"end\":return _context.stop();}}},_callee);}));this.onTick=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tickDelta){var _this$inputs,speed,enabled,_u,_this$getPoseAt,position,rotation;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_this$inputs=_this.inputs,speed=_this$inputs.speed,enabled=_this$inputs.enabled;if(enabled){_this.u=clamp(_this.u+speed*(tickDelta/1000)/_this.length,0,1);_u=_this.u;_this$getPoseAt=_this.getPoseAt(_u),position=_this$getPoseAt.position,rotation=_this$getPoseAt.rotation;_this.setCamera(position,rotation);_this.inputs.changeUCallback(_u);}case 2:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x){return _ref2.apply(this,arguments);};}();this.onDestroy=function(){};}_createClass(CameraController,[{key:\"getPoseAt\",value:/**\n   * Given u along curve, return position and rotation for camera.\n   */function getPoseAt(u){var _this$inputs2=this.inputs,curve=_this$inputs2.curve,speed=_this$inputs2.speed,verticalOffset=_this$inputs2.verticalOffset;var THREE=this.context.three;// position\nvar uPast=Math.max(u-0.1*speed/this.length,0);// 0.1 second in past\nvar uFuture=Math.min(u+speed/this.length,1);// 1 second in the future\nvar position=curve.getPointAt(u);position.y+=verticalOffset;// add vertical offset;\nvar positionPast=curve.getPointAt(uPast);var positionFuture=curve.getPointAt(uFuture);// rotation\nvar matrix=new THREE.Matrix4().lookAt(positionPast,positionFuture,this.up);var rotation=new THREE.Euler().setFromRotationMatrix(matrix,\"YXZ\");return{position:position,rotation:rotation};}/**\n   * Set camera pose.\n   */},{key:\"setCamera\",value:function setCamera(position,rotation){var camera=this.outputs.camera;camera.position.copy(position);camera.rotation.copy(rotation);camera.updateProjectionMatrix();}/**\n   * Manually set u for camera.\n   */},{key:\"setU\",value:function setU(u){this.u=u;var _this$getPoseAt2=this.getPoseAt(u),position=_this$getPoseAt2.position,rotation=_this$getPoseAt2.rotation;this.setCamera(position,rotation);this.inputs.changeUCallback(u);}// --- IComponent methods ----------------------------------------------------\n}]);return CameraController;}();export var cameraControllerType='sdk-component.cameraController';export function CameraControllerFactory(){return new CameraController();}","map":{"version":3,"sources":["/Users/sallen/Documents/GitHub/sdk_wayfinder/src/app/sdk-components/CameraController.ts"],"names":["clamp","CameraController","u","length","up","inputs","curve","speed","verticalOffset","enabled","changeUCallback","outputs","camera","context","onInit","THREE","three","PerspectiveCamera","getLength","Vector3","onTick","tickDelta","getPoseAt","position","rotation","setCamera","onDestroy","uPast","Math","max","uFuture","min","getPointAt","y","positionPast","positionFuture","matrix","Matrix4","lookAt","Euler","setFromRotationMatrix","copy","updateProjectionMatrix","cameraControllerType","CameraControllerFactory"],"mappings":"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","sourcesContent":["import { Vector3 } from '../../mp/sdk';\nimport { clamp } from '../utils';\n\ntype Euler = {\n\tx: number;\n\ty: number;\n\tz: number;\n  order: string;\n};\n\ninterface CameraControllerInputs {\n  curve: any, \n  speed: number, \n  verticalOffset: number, \n  enabled: boolean, \n  changeUCallback: (u: number) => void, \n}\n\ninterface CameraControllerOutputs {\n  camera: any,\n}\n\nclass CameraController {\n\n  private u: number = 0; // number in [0, 1] representing position along curve\n  private length: number = 0; // length of curve\n  private up: undefined | Vector3;\n\n  private inputs: CameraControllerInputs = {\n    curve: null, // THREE.Curve object\n    speed: 1.5, // speed in meters per second\n    verticalOffset: 1., // vertical offset from curve\n    enabled: false, // true to move forward automatically, false to pause\n    changeUCallback: (u) => null, // callback eahc time u changes\n  };\n\n  private outputs = {\n    camera: null,\n  } as CameraControllerOutputs;\n\n  private context: any;\n\n  /**\n   * Given u along curve, return position and rotation for camera.\n   */\n  private getPoseAt(u: number): {position: Vector3, rotation: Euler} {\n    const { curve, speed, verticalOffset } = this.inputs;\n    const THREE = this.context.three;\n    // position\n    const uPast = Math.max(u - 0.1 * speed / this.length, 0); // 0.1 second in past\n    const uFuture = Math.min(u + speed / this.length, 1); // 1 second in the future\n    const position = curve.getPointAt(u);\n    position.y += verticalOffset; // add vertical offset;\n    const positionPast = curve.getPointAt(uPast);\n    const positionFuture = curve.getPointAt(uFuture);\n    // rotation\n    const matrix = new THREE.Matrix4().lookAt(positionPast, positionFuture, this.up);\n    const rotation = new THREE.Euler().setFromRotationMatrix(matrix, \"YXZ\");\n    return { position, rotation };\n  }\n\n  /**\n   * Set camera pose.\n   */\n  private setCamera(position: Vector3, rotation: Euler) {\n    const { camera } = this.outputs;\n    camera.position.copy(position);\n    camera.rotation.copy(rotation);\n    camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Manually set u for camera.\n   */\n  public setU(u: number) {\n    this.u = u;\n    const { position, rotation } = this.getPoseAt(u);\n    this.setCamera(position, rotation);\n    this.inputs.changeUCallback(u);\n  }\n\n  // --- IComponent methods ----------------------------------------------------\n\n  public onInit = async () => {\n    const { curve } = this.inputs;\n    const THREE = this.context.three;\n\n    const camera = new THREE.PerspectiveCamera( 45, 1.333, 1, 1000 );\n    this.outputs.camera = camera;\n    this.length = curve.getLength() - 1;\n    this.up = new THREE.Vector3(0, 1, 0);\n  };\n\n  public onTick = async (tickDelta: number) => {\n    const { speed, enabled } = this.inputs;\n    if (enabled) {\n      this.u = clamp(this.u + speed * (tickDelta/1000) / this.length, 0, 1);\n      const { u } = this;\n      const { position, rotation } = this.getPoseAt(u);\n      this.setCamera(position, rotation);\n      this.inputs.changeUCallback(u);\n    }\n  };\n\n  public onDestroy = function() {\n  };\n}\n\nexport const cameraControllerType = 'sdk-component.cameraController';\nexport function CameraControllerFactory() {\n  return new CameraController();\n}\n"]},"metadata":{},"sourceType":"module"}