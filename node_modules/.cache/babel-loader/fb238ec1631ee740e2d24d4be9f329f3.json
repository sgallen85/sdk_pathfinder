{"ast":null,"code":"import { distance } from './utils';\n/**\n * Path given by `findShortestPath` as list of sweep ids. It's a separate type\n * just in case the return type changes.\n */\n\nexport default class Pathfinder {\n  // penalize sweeps vertically separated by this distance, in meters\n  // penalize sweeps horizontally separated by this distance, in meters\n  constructor(sweepData) {\n    this.VERT_THRESHOLD = 0.5;\n    this.HORZ_THRESHOLD = 10.0;\n    this.graph = {};\n    this.path = [];\n    this.sweepPositions = {};\n    // init sweepPositions\n    sweepData.forEach(sweep => this.sweepPositions[sweep.sid] = sweep.position);\n    this.createGraph(sweepData);\n  }\n  /**\n   * Generate graph of sweep distances.\n   * @param {Sweep.SweepData[]} sweeps List of sweep data, such as `sdk.Model.getData().sweeps`\n   */\n\n\n  createGraph(sweeps) {\n    const graph = {};\n\n    for (let i = 0; i < sweeps.length; i++) {\n      const sweep_a = sweeps[i];\n      const adj = {};\n      const neighbor_sids = sweep_a.neighbors;\n\n      for (let j = 0; j < neighbor_sids.length; j++) {\n        const sweep_b_sid = neighbor_sids[j];\n        const d = distance(sweep_a.position, this.sweepPositions[sweep_b_sid]);\n        adj[sweep_b_sid] = d;\n      }\n\n      graph[sweep_a.sid] = adj;\n    }\n\n    this.graph = graph;\n  }\n  /**\n   * Heuristic function for A*. Just take Euclidean distance.\n   */\n\n\n  heuristic(i_sid, j_sid) {\n    const {\n      sweepPositions\n    } = this;\n    return distance(sweepPositions[i_sid], sweepPositions[j_sid]);\n  }\n  /**\n   * Additional penalty to avoid large vertical/horizontal jumps.\n   */\n\n\n  penalty(i_sid, j_sid) {\n    const {\n      sweepPositions\n    } = this;\n    return ((sweepPositions[i_sid].y - sweepPositions[j_sid].y) / this.VERT_THRESHOLD) ** 4 + ((sweepPositions[i_sid].x - sweepPositions[j_sid].x) ** 2 + (sweepPositions[i_sid].z - sweepPositions[j_sid].z) ** 2) / this.HORZ_THRESHOLD;\n  }\n  /**\n   * Find shortest path between two sweeps connected by valid movements.\n   * @param {string} a_sid SID of starting sweep.\n   * @param {string} b_sid SID of ending sweep.\n   * @returns {SweepPath} Path from `a_sid` to `b_sid`.\n   */\n\n\n  async findShortestPath(a_sid, b_sid) {\n    const {\n      graph\n    } = this; // check SIDs are valid\n\n    if (graph[a_sid] === undefined || graph[b_sid] === undefined) {\n      console.error('Sweep SID(s) is invalid.');\n      return;\n    }\n\n    const ht = {}; // hash table that stores the following info for each encountered sweep:\n\n    ht[a_sid] = {\n      visited: false,\n      distance: 0,\n      cost: 0,\n      parent: null\n    }; // loop A* algorithm\n\n    let debug_n = 0; // count number of iterations\n\n    while (true) {\n      debug_n += 1; // find unvisited sweep with minimum cost = distance + heuristic\n      // TODO: optimize with priority queue\n\n      let min_sid;\n      const encountered_sids = Object.keys(ht);\n\n      for (let i = 0; i < encountered_sids.length; i++) {\n        const sid = encountered_sids[i];\n\n        if (!ht[sid].visited && (min_sid === undefined || ht[sid].cost < ht[min_sid].cost)) {\n          min_sid = sid;\n        }\n      }\n\n      if (min_sid === undefined) {\n        console.error('Could not find path; sweeps are not connected.');\n        return;\n      } // check if sweep is ending point\n\n\n      if (min_sid === b_sid) {\n        break;\n      } // add all neighbors of `min_sid`\n\n\n      ht[min_sid].visited = true;\n      const neighbor_sids = Object.keys(graph[min_sid]);\n\n      for (let i = 0; i < neighbor_sids.length; i++) {\n        const sid = neighbor_sids[i];\n        const dist = ht[min_sid].distance + graph[min_sid][sid];\n        const cost = dist + this.penalty(min_sid, sid) + this.heuristic(sid, b_sid);\n\n        if (sid in ht) {\n          // if sweep has been encountered\n          if (!ht[sid].visited && ht[sid].cost > cost) {\n            // if not visited and smaller cost, then update\n            ht[sid].parent = min_sid;\n            ht[sid].distance = dist;\n            ht[sid].cost = cost;\n          }\n        } else {\n          // if sweep has not been encountered yet\n          ht[sid] = {\n            visited: false,\n            distance: dist,\n            cost: cost,\n            parent: min_sid\n          };\n        }\n      }\n    }\n\n    console.log(`Pathfind iterations: ${debug_n}`); // traverse graph back to starting point\n\n    let sid = b_sid;\n    const path = [sid];\n\n    while (ht[sid].parent !== null) {\n      sid = ht[sid].parent;\n      path.push(sid);\n    }\n\n    path.reverse();\n    return path;\n  }\n\n}","map":{"version":3,"sources":["/Users/sallen/Documents/GitHub/sdk_wayfinder/src/app/Pathfinder.ts"],"names":["distance","Pathfinder","constructor","sweepData","VERT_THRESHOLD","HORZ_THRESHOLD","graph","path","sweepPositions","forEach","sweep","sid","position","createGraph","sweeps","i","length","sweep_a","adj","neighbor_sids","neighbors","j","sweep_b_sid","d","heuristic","i_sid","j_sid","penalty","y","x","z","findShortestPath","a_sid","b_sid","undefined","console","error","ht","visited","cost","parent","debug_n","min_sid","encountered_sids","Object","keys","dist","log","push","reverse"],"mappings":"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","sourcesContent":["import { Sweep, Vector3 } from '../mp/sdk';\nimport { distance } from './utils';\n\n/**\n * Path given by `findShortestPath` as list of sweep ids. It's a separate type\n * just in case the return type changes.\n */\nexport type SweepPath = string[];\n\n/**\n * Graph as adjacency list, with sweep ids mapping to a list of neighboring ids,\n * who each map to corresponding distances.\n */\ninterface SweepGraph {\n  [a_id: string]: AdjacencyNode;\n}\ninterface AdjacencyNode {\n  [b_id: string]: number;\n}\n\nexport interface SweepPositions {\n  [id: string]: Vector3;\n}\n\nexport default class Pathfinder {\n\n  private VERT_THRESHOLD = 0.5; // penalize sweeps vertically separated by this distance, in meters\n  private HORZ_THRESHOLD = 10.0; // penalize sweeps horizontally separated by this distance, in meters\n\n  private graph: SweepGraph = {};\n  public path: SweepPath = [];\n\n  private sweepPositions: SweepPositions = {};\n\n  constructor(sweepData: Sweep.SweepData[]) {\n    // init sweepPositions\n    sweepData.forEach(sweep => this.sweepPositions[sweep.sid] = sweep.position);\n    this.createGraph(sweepData);\n  }\n\n  /**\n   * Generate graph of sweep distances.\n   * @param {Sweep.SweepData[]} sweeps List of sweep data, such as `sdk.Model.getData().sweeps`\n   */\n  private createGraph(sweeps: Sweep.SweepData[]): void {\n    const graph: SweepGraph = {};\n    for (let i = 0; i < sweeps.length; i++) {\n      const sweep_a = sweeps[i];\n      const adj: AdjacencyNode = {};\n      const neighbor_sids = sweep_a.neighbors;\n      for (let j = 0; j < neighbor_sids.length; j++) {\n        const sweep_b_sid = neighbor_sids[j];\n        const d = distance(sweep_a.position, this.sweepPositions[sweep_b_sid]);\n        adj[sweep_b_sid] = d;\n      }\n      graph[sweep_a.sid] = adj;\n    }\n    this.graph = graph;\n  }\n\n  /**\n   * Heuristic function for A*. Just take Euclidean distance.\n   */\n  private heuristic(i_sid: string, j_sid: string): number {\n    const { sweepPositions } = this;\n    return distance(sweepPositions[i_sid], sweepPositions[j_sid]);\n  }\n\n  /**\n   * Additional penalty to avoid large vertical/horizontal jumps.\n   */\n  private penalty(i_sid: string, j_sid: string): number {\n    const { sweepPositions } = this;\n    return ((sweepPositions[i_sid].y - sweepPositions[j_sid].y) / this.VERT_THRESHOLD) ** 4\n      + (((sweepPositions[i_sid].x - sweepPositions[j_sid].x) ** 2 + (sweepPositions[i_sid].z - sweepPositions[j_sid].z) ** 2) / this.HORZ_THRESHOLD);\n  }\n\n  /**\n   * Find shortest path between two sweeps connected by valid movements.\n   * @param {string} a_sid SID of starting sweep.\n   * @param {string} b_sid SID of ending sweep.\n   * @returns {SweepPath} Path from `a_sid` to `b_sid`.\n   */\n  public async findShortestPath(a_sid: string, b_sid: string): Promise<SweepPath | undefined> {\n\n    const { graph } = this;\n\n    // check SIDs are valid\n    if (graph[a_sid] === undefined || graph[b_sid] === undefined) {\n      console.error('Sweep SID(s) is invalid.');\n      return;\n    }\n\n    const ht: any = {}; // hash table that stores the following info for each encountered sweep:\n    ht[a_sid] = { visited: false, distance: 0, cost: 0, parent: null };\n\n    // loop A* algorithm\n    let debug_n = 0; // count number of iterations\n\n    while (true) {\n      debug_n += 1;\n      // find unvisited sweep with minimum cost = distance + heuristic\n      // TODO: optimize with priority queue\n      let min_sid;\n      const encountered_sids = Object.keys(ht);\n      for (let i = 0; i < encountered_sids.length; i++) {\n        const sid = encountered_sids[i];\n        if (!ht[sid].visited && (min_sid === undefined || ht[sid].cost < ht[min_sid].cost)) {\n          min_sid = sid;\n        }\n      }\n      if (min_sid === undefined) {\n        console.error('Could not find path; sweeps are not connected.');\n        return;\n      }\n      // check if sweep is ending point\n      if (min_sid === b_sid) {\n        break;\n      }\n      // add all neighbors of `min_sid`\n      ht[min_sid].visited = true;\n      const neighbor_sids = Object.keys(graph[min_sid]);\n      for (let i = 0; i < neighbor_sids.length; i++) {\n        const sid = neighbor_sids[i];\n        const dist = ht[min_sid].distance + graph[min_sid][sid];\n        const cost = dist + this.penalty(min_sid, sid) + this.heuristic(sid, b_sid);\n        if (sid in ht) { // if sweep has been encountered\n          if (!ht[sid].visited && (ht[sid].cost > cost)) { // if not visited and smaller cost, then update\n            ht[sid].parent = min_sid;\n            ht[sid].distance = dist;\n            ht[sid].cost = cost;\n          }\n        } else { // if sweep has not been encountered yet\n          ht[sid] = { visited: false, distance: dist, cost: cost, parent: min_sid };\n        }\n      }\n    }\n    console.log(`Pathfind iterations: ${debug_n}`);\n\n    // traverse graph back to starting point\n    let sid = b_sid;\n    const path: string[] = [sid];\n    while (ht[sid].parent !== null) {\n      sid = ht[sid].parent as string;\n      path.push(sid);\n    }\n    path.reverse();\n    return path;\n\n  }\n}"]},"metadata":{},"sourceType":"module"}