{"ast":null,"code":"import { clamp } from '../utils';\n\nclass CameraController {\n  constructor() {\n    this.u = 0;\n    this.length = 0;\n    this.up = void 0;\n    this.inputs = {\n      curve: null,\n      // THREE.Curve object\n      speed: 1.5,\n      // speed in meters per second\n      verticalOffset: 1.,\n      // vertical offset from curve\n      enabled: false,\n      // true to move forward automatically, false to pause\n      changeUCallback: u => null // callback eahc time u changes\n\n    };\n    this.outputs = {\n      camera: null\n    };\n    this.context = void 0;\n\n    this.onInit = async () => {\n      const {\n        curve\n      } = this.inputs;\n      const THREE = this.context.three;\n      const camera = new THREE.PerspectiveCamera(45, 1.333, 1, 1000);\n      this.outputs.camera = camera;\n      this.length = curve.getLength() - 1;\n      this.up = new THREE.Vector3(0, 1, 0);\n    };\n\n    this.onTick = async tickDelta => {\n      const {\n        speed,\n        enabled\n      } = this.inputs;\n\n      if (enabled) {\n        this.u = clamp(this.u + speed * (tickDelta / 1000) / this.length, 0, 1);\n        const {\n          u\n        } = this;\n        const {\n          position,\n          rotation\n        } = this.getPoseAt(u);\n        this.setCamera(position, rotation);\n        this.inputs.changeUCallback(u);\n      }\n    };\n\n    this.onDestroy = function () {};\n  }\n\n  /**\n   * Given u along curve, return position and rotation for camera.\n   */\n  getPoseAt(u) {\n    const {\n      curve,\n      speed,\n      verticalOffset\n    } = this.inputs;\n    const THREE = this.context.three; // position\n\n    const uPast = Math.max(u - 0.1 * speed / this.length, 0); // 0.1 second in past\n\n    const uFuture = Math.min(u + speed / this.length, 1); // 1 second in the future\n\n    const position = curve.getPointAt(u);\n    position.y += verticalOffset; // add vertical offset;\n\n    const positionPast = curve.getPointAt(uPast);\n    const positionFuture = curve.getPointAt(uFuture); // rotation\n\n    const matrix = new THREE.Matrix4().lookAt(positionPast, positionFuture, this.up);\n    const rotation = new THREE.Euler().setFromRotationMatrix(matrix, \"YXZ\");\n    return {\n      position,\n      rotation\n    };\n  }\n  /**\n   * Set camera pose.\n   */\n\n\n  setCamera(position, rotation) {\n    const {\n      camera\n    } = this.outputs;\n    camera.position.copy(position);\n    camera.rotation.copy(rotation);\n    camera.updateProjectionMatrix();\n  }\n  /**\n   * Manually set u for camera.\n   */\n\n\n  setU(u) {\n    this.u = u;\n    const {\n      position,\n      rotation\n    } = this.getPoseAt(u);\n    this.setCamera(position, rotation);\n    this.inputs.changeUCallback(u);\n  } // --- IComponent methods ----------------------------------------------------\n\n\n}\n\nexport const cameraControllerType = 'sdk-component.cameraController';\nexport function CameraControllerFactory() {\n  return new CameraController();\n}\n_c = CameraControllerFactory;\n\nvar _c;\n\n$RefreshReg$(_c, \"CameraControllerFactory\");","map":{"version":3,"sources":["/Users/sallen/Documents/GitHub/sdk_wayfinder/src/app/sdk-components/CameraController.ts"],"names":["clamp","CameraController","u","length","up","inputs","curve","speed","verticalOffset","enabled","changeUCallback","outputs","camera","context","onInit","THREE","three","PerspectiveCamera","getLength","Vector3","onTick","tickDelta","position","rotation","getPoseAt","setCamera","onDestroy","uPast","Math","max","uFuture","min","getPointAt","y","positionPast","positionFuture","matrix","Matrix4","lookAt","Euler","setFromRotationMatrix","copy","updateProjectionMatrix","setU","cameraControllerType","CameraControllerFactory"],"mappings":"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","sourcesContent":["import { Vector3 } from '../../mp/sdk';\nimport { clamp } from '../utils';\n\ntype Euler = {\n\tx: number;\n\ty: number;\n\tz: number;\n  order: string;\n};\n\ninterface CameraControllerInputs {\n  curve: any, \n  speed: number, \n  verticalOffset: number, \n  enabled: boolean, \n  changeUCallback: (u: number) => void, \n}\n\ninterface CameraControllerOutputs {\n  camera: any,\n}\n\nclass CameraController {\n\n  private u: number = 0; // number in [0, 1] representing position along curve\n  private length: number = 0; // length of curve\n  private up: undefined | Vector3;\n\n  private inputs: CameraControllerInputs = {\n    curve: null, // THREE.Curve object\n    speed: 1.5, // speed in meters per second\n    verticalOffset: 1., // vertical offset from curve\n    enabled: false, // true to move forward automatically, false to pause\n    changeUCallback: (u) => null, // callback eahc time u changes\n  };\n\n  private outputs = {\n    camera: null,\n  } as CameraControllerOutputs;\n\n  private context: any;\n\n  /**\n   * Given u along curve, return position and rotation for camera.\n   */\n  private getPoseAt(u: number): {position: Vector3, rotation: Euler} {\n    const { curve, speed, verticalOffset } = this.inputs;\n    const THREE = this.context.three;\n    // position\n    const uPast = Math.max(u - 0.1 * speed / this.length, 0); // 0.1 second in past\n    const uFuture = Math.min(u + speed / this.length, 1); // 1 second in the future\n    const position = curve.getPointAt(u);\n    position.y += verticalOffset; // add vertical offset;\n    const positionPast = curve.getPointAt(uPast);\n    const positionFuture = curve.getPointAt(uFuture);\n    // rotation\n    const matrix = new THREE.Matrix4().lookAt(positionPast, positionFuture, this.up);\n    const rotation = new THREE.Euler().setFromRotationMatrix(matrix, \"YXZ\");\n    return { position, rotation };\n  }\n\n  /**\n   * Set camera pose.\n   */\n  private setCamera(position: Vector3, rotation: Euler) {\n    const { camera } = this.outputs;\n    camera.position.copy(position);\n    camera.rotation.copy(rotation);\n    camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Manually set u for camera.\n   */\n  public setU(u: number) {\n    this.u = u;\n    const { position, rotation } = this.getPoseAt(u);\n    this.setCamera(position, rotation);\n    this.inputs.changeUCallback(u);\n  }\n\n  // --- IComponent methods ----------------------------------------------------\n\n  public onInit = async () => {\n    const { curve } = this.inputs;\n    const THREE = this.context.three;\n\n    const camera = new THREE.PerspectiveCamera( 45, 1.333, 1, 1000 );\n    this.outputs.camera = camera;\n    this.length = curve.getLength() - 1;\n    this.up = new THREE.Vector3(0, 1, 0);\n  };\n\n  public onTick = async (tickDelta: number) => {\n    const { speed, enabled } = this.inputs;\n    if (enabled) {\n      this.u = clamp(this.u + speed * (tickDelta/1000) / this.length, 0, 1);\n      const { u } = this;\n      const { position, rotation } = this.getPoseAt(u);\n      this.setCamera(position, rotation);\n      this.inputs.changeUCallback(u);\n    }\n  };\n\n  public onDestroy = function() {\n  };\n}\n\nexport const cameraControllerType = 'sdk-component.cameraController';\nexport function CameraControllerFactory() {\n  return new CameraController();\n}\n"]},"metadata":{},"sourceType":"module"}